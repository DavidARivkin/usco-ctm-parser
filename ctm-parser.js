/**
 * Loader for CTM encoded models generated by OpenCTM tools:
 *	http://openctm.sourceforge.net/
 *
 * Uses js-openctm library by Juan Mellado
 *	http://code.google.com/p/js-openctm/
 *
 * @author alteredq / http://alteredqualia.com/
 */
var detectEnv = require("composite-detect");

if(detectEnv.isNode)    var THREE = require("three");
if(detectEnv.isBrowser) var THREE = window.THREE;
if (detectEnv.isModule) var CTM = require("./ctm");
if (detectEnv.isModule) var Q = require('q');

CTMParser = function ( showStatus ) {

  this.outputs = ["geometry"]; //to be able to auto determine data type(s) fetched by parser
  this.inputDataType = "arrayBuffer"
	THREE.Loader.call( this, showStatus );

};

function toArrayBuffer(buffer) {
    var ab = new ArrayBuffer(buffer.length);
    var view = new Uint8Array(ab);
    for (var i = 0; i < buffer.length; ++i) {
        view[i] = buffer[i];
    }
    return ab;
}

function str2ab(str) {
  var buf = new ArrayBuffer(str.length*2); // 2 bytes for each char
  var bufView = new Uint16Array(buf);
  for (var i=0, strLen=str.length; i<strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}

function str2ab2(str)
{
   var idx, len = str.length, arr = new Array( len );
    for ( idx = 0 ; idx < len ; ++idx ) {
        arr[ idx ] = str.charCodeAt(idx) & 0xFF;
    }
    // You may create an ArrayBuffer from a standard array (of values) as follows:
    return new Uint8Array( arr ).buffer;
}

CTMParser.prototype.ensureArrayBuffer = function( data )
{
  if (typeof data == 'string' || data instanceof String)
  {
    return str2ab2(data);
  }
  else
  {
    return data;
  }
}

// Load CTM compressed models
//  - parameters
CTMParser.prototype.parse = function( data, parameters ) {
	var scope = this;

  var parameters = parameters || {};
	var offsets    = parameters.offsets !== undefined ? parameters.offsets : [ 0 ];
	var useBuffers = parameters.useBuffers !== undefined ? parameters.useBuffers : false;
  var useWorker  = parameters.useWorker !== undefined ?  parameters.useWorker && detectEnv.isBrowser: true;
  var rawBuffers = parameters.rawBuffers !== undefined ? parameters.rawBuffers : false;
  
  var deferred = Q.defer();

	var length = 0;
  //var binaryData = new Uint8Array(data);
  //var binaryData = new Uint8Array( new ArrayBuffer(data) );
  //var binaryData = new Buffer( new Uint8Array(data) );
  
//TODO: this is only temporary for NODE.js side
  //var data = toArrayBuffer(data);
  data = this.ensureArrayBuffer( data ); 
  
  binaryData = new Uint8Array(data);
  var result = null;  

  var s = Date.now();

  //useBuffers = false;
	if ( useWorker ) {
		var worker = new Worker( "./CTMWorker.js" );

		worker.onmessage = function( event ) {
			var files = event.data;
			for ( var i = 0; i < files.length; i ++ ) {
				var ctmFile = files[ i ];
				var e1 = Date.now();
				// console.log( "CTM data parse time [worker]: " + (e1-s) + " ms" );
				if ( useBuffers ) {
					var geometry = scope.createModelBuffers( ctmFile );
					deferred.notify( {"parsing":100,"total":Math.NaN} )
          deferred.resolve( geometry );
				} else {
					var geometry = scope.createModelClassic( ctmFile );
					deferred.notify( {"parsing":100,"total":Math.NaN} )
          deferred.resolve( geometry );
				}
				var e = Date.now();
				console.log( "model load time [worker]: " + (e-e1) + " ms, total: " + (e-s));
			}
		};
	  worker.postMessage( { "data": binaryData, "offsets": offsets } );
	  Q.catch( deferred.promise, function(){
		  worker.terminate()
		});
	} else {
		for ( var i = 0; i < offsets.length; i ++ ) {
			var stream = new CTM.Stream( binaryData );

      //console.log("stream",stream)
			stream.offset = offsets[ i ];
      //console.log("stream offset", offsets[ i ])
			var ctmFile = new CTM.File( stream );

			if ( useBuffers ) {
				var geometry = scope.createModelBuffers( ctmFile );
				deferred.notify( {"parsing":100,"total":Math.NaN} )
        deferred.resolve( geometry );
			} else {
				var geometry = scope.createModelClassic( ctmFile );
				deferred.notify( {"parsing":100,"total":Math.NaN} )
        deferred.resolve( geometry );
			}
		 }
		var e = Date.now();
		console.log( "CTM data parse time [inline]: " + (e-s) + " ms" );
	 }

  //return result;
  return deferred;
} 

CTMParser.prototype.createModelBuffers = function ( file ) {
  console.log("creating model buffers")

var Model = function () {

		THREE.BufferGeometry.call( this );

		this.materials = [];

		var indices = file.body.indices,
		positions = file.body.vertices,
		normals = file.body.normals;

		var uvs, colors;

		var uvMaps = file.body.uvMaps;

		if ( uvMaps !== undefined && uvMaps.length > 0 ) {

			uvs = uvMaps[ 0 ].uv;

		}

		var attrMaps = file.body.attrMaps;

		if ( attrMaps !== undefined && attrMaps.length > 0 && attrMaps[ 0 ].name === 'Color' ) {

			colors = attrMaps[ 0 ].attr;

		}

		this.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

		if ( normals !== undefined ) {

			this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );

		}

		if ( uvs !== undefined ) {

			this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		}

		if ( colors !== undefined ) {

			this.addAttribute( 'color', new THREE.BufferAttribute( colors, 4 ) );

		}

	}

	Model.prototype = Object.create( THREE.BufferGeometry.prototype );

	var geometry = new Model();

	geometry.computeOffsets();

	// compute vertex normals if not present in the CTM model
	if ( geometry.attributes.normal === undefined ) {
		geometry.computeVertexNormals();
	}


  return geometry;
};

CTMParser.prototype.createModelClassic = function ( file ) {

	var Model = function ( ) {

		var scope = this;

		scope.materials = [];

		THREE.Geometry.call( this );

		var normals = [],
			uvs = [],
			colors = [];

		init_vertices( file.body.vertices );

		if ( file.body.normals !== undefined )
			init_normals( file.body.normals );

		if ( file.body.uvMaps !== undefined && file.body.uvMaps.length > 0 )
			init_uvs( file.body.uvMaps[ 0 ].uv );

		if ( file.body.attrMaps !== undefined && file.body.attrMaps.length > 0 && file.body.attrMaps[ 0 ].name === "Color" )
			init_colors( file.body.attrMaps[ 0 ].attr );

		var hasNormals = normals.length > 0 ? true : false,
			hasUvs = uvs.length > 0 ? true : false,
			hasColors = colors.length > 0 ? true : false;

		init_faces( file.body.indices );

		//this.computeTangents();

		function init_vertices( buffer ) {

			var x, y, z, i, il = buffer.length;

			for( i = 0; i < il; i += 3 ) {

				x = buffer[ i ];
				y = buffer[ i + 1 ];
				z = buffer[ i + 2 ];

				vertex( scope, x, y, z );

			}

		};

		function init_normals( buffer ) {

			var x, y, z, i, il = buffer.length;

			for( i = 0; i < il; i += 3 ) {

				x = buffer[ i ];
				y = buffer[ i + 1 ];
				z = buffer[ i + 2 ];

				normals.push( x, y, z );

			}

		};

		function init_colors( buffer ) {

			var r, g, b, a, i, il = buffer.length;

			for( i = 0; i < il; i += 4 ) {

				r = buffer[ i ];
				g = buffer[ i + 1 ];
				b = buffer[ i + 2 ];
				a = buffer[ i + 3 ];

				var color = new THREE.Color();
				color.setRGB( r, g, b );

				colors.push( color );

			}

		};


		function init_uvs( buffer ) {

			var u, v, i, il = buffer.length;

			for( i = 0; i < il; i += 2 ) {

				u = buffer[ i ];
				v = buffer[ i + 1 ];

				uvs.push( u, v );

			}

		};

		function init_faces( buffer ) {

			var a, b, c,
				u1, v1, u2, v2, u3, v3,
				m, face,
				i, il = buffer.length;

			m = 0; // all faces defaulting to material 0

			for( i = 0; i < il; i += 3 ) {

				a = buffer[ i ];
				b = buffer[ i + 1 ];
				c = buffer[ i + 2 ];

				if ( hasNormals ){

					face = f3n( scope, normals, a, b, c, m, a, b, c );

				} else {

					face = f3( scope, a, b, c, m );

				}

				if ( hasColors ) {

					face.vertexColors[ 0 ] = colors[ a ];
					face.vertexColors[ 1 ] = colors[ b ];
					face.vertexColors[ 2 ] = colors[ c ];

				}

				if ( hasUvs ) {

					u1 = uvs[ a * 2 ];
					v1 = uvs[ a * 2 + 1 ];

					u2 = uvs[ b * 2 ];
					v2 = uvs[ b * 2 + 1 ];

					u3 = uvs[ c * 2 ];
					v3 = uvs[ c * 2 + 1 ];

					uv3( scope.faceVertexUvs[ 0 ], u1, v1, u2, v2, u3, v3 );

				}

			}

		}

	};

	function vertex ( scope, x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	};

	function f3 ( scope, a, b, c, mi ) {

		var face = new THREE.Face3( a, b, c, null, null, mi );

		scope.faces.push( face );

		return face;

	};

	function f3n ( scope, normals, a, b, c, mi, nai, nbi, nci ) {

		var nax = normals[ nai * 3     ],
			nay = normals[ nai * 3 + 1 ],
			naz = normals[ nai * 3 + 2 ],

			nbx = normals[ nbi * 3     ],
			nby = normals[ nbi * 3 + 1 ],
			nbz = normals[ nbi * 3 + 2 ],

			ncx = normals[ nci * 3     ],
			ncy = normals[ nci * 3 + 1 ],
			ncz = normals[ nci * 3 + 2 ];

		var na = new THREE.Vector3( nax, nay, naz ),
			nb = new THREE.Vector3( nbx, nby, nbz ),
			nc = new THREE.Vector3( ncx, ncy, ncz );

		var face = new THREE.Face3( a, b, c, [ na, nb, nc ], null, mi );

		scope.faces.push( face );

		return face;

	};

	function uv3 ( where, u1, v1, u2, v2, u3, v3 ) {

		var uv = [];
		uv.push( new THREE.Vector2( u1, v1 ) );
		uv.push( new THREE.Vector2( u2, v2 ) );
		uv.push( new THREE.Vector2( u3, v3 ) );
		where.push( uv );

	};

	Model.prototype = Object.create( THREE.Geometry.prototype );

	//callback( new Model() );
  return new Model();
};

if (detectEnv.isModule) module.exports = CTMParser;
