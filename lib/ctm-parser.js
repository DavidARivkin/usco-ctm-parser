require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"suCbHP":[function(require,module,exports){
/**
 * Loader for CTM encoded models generated by OpenCTM tools:
 *	http://openctm.sourceforge.net/
 *
 * Uses js-openctm library by Juan Mellado
 *	http://code.google.com/p/js-openctm/
 *
 * @author alteredq / http://alteredqualia.com/
 */
var detectEnv = require("composite-detect");

if(detectEnv.isNode)    var THREE = require("three");
if(detectEnv.isBrowser) var THREE = window.THREE;
if (detectEnv.isModule) var CTM = require("./ctm");
if (detectEnv.isModule) var Q = require('q');

CTMParser = function ( showStatus ) {

  this.outputs = ["geometry"]; //to be able to auto determine data type(s) fetched by parser
  this.inputDataType = "arrayBuffer"
	THREE.Loader.call( this, showStatus );

};

function toArrayBuffer(buffer) {
    var ab = new ArrayBuffer(buffer.length);
    var view = new Uint8Array(ab);
    for (var i = 0; i < buffer.length; ++i) {
        view[i] = buffer[i];
    }
    return ab;
}

function str2ab(str) {
  var buf = new ArrayBuffer(str.length*2); // 2 bytes for each char
  var bufView = new Uint16Array(buf);
  for (var i=0, strLen=str.length; i<strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}

function str2ab2(str)
{
   var idx, len = str.length, arr = new Array( len );
    for ( idx = 0 ; idx < len ; ++idx ) {
        arr[ idx ] = str.charCodeAt(idx) & 0xFF;
    }
    // You may create an ArrayBuffer from a standard array (of values) as follows:
    return new Uint8Array( arr ).buffer;
}

CTMParser.prototype.ensureArrayBuffer = function( data )
{
  if (typeof data == 'string' || data instanceof String)
  {
    return str2ab2(data);
  }
  else
  {
    return data;
  }
}

// Load CTM compressed models
//  - parameters
CTMParser.prototype.parse = function( data, parameters ) {
	var scope = this;

  var parameters = parameters || {};
	var offsets = parameters.offsets !== undefined ? parameters.offsets : [ 0 ];
	var useBuffers = parameters.useBuffers !== undefined ? parameters.useBuffers : false;

  parameters.useWorker = detectEnv.isBrowser;
  var deferred = Q.defer();

	var length = 0;
  //var binaryData = new Uint8Array(data);
  //var binaryData = new Uint8Array( new ArrayBuffer(data) );
  //var binaryData = new Buffer( new Uint8Array(data) );
  
//TODO: this is only temporary for NODE.js side
  //var data = toArrayBuffer(data);
  data = this.ensureArrayBuffer( data ); 
  
  binaryData = new Uint8Array(data);
  var result = null;  

  var s = Date.now();

	if ( parameters.useWorker ) {
		var worker = new Worker(window.URL.createObjectURL(new Blob([';(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module \'"+n+"\'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){\n//importScripts( "../ctm.js","lzma.js" );\nvar CTM = require("./ctm");\nvar lzma = require("./lzma");\n\nself.onmessage = function( event ) {\n\n\tvar files = [];\n\n\tfor ( var i = 0; i < event.data.offsets.length; i ++ ) {\n\n\t\tvar stream = new CTM.Stream( event.data.data );\n\t\tstream.offset = event.data.offsets[ i ];\n\n\t\tfiles[ i ] = new CTM.File( stream );\n\n\t}\n\n\tself.postMessage( files );\n\tself.close();\n\n}\n\n},{"./ctm":2,"./lzma":3}],2:[function(require,module,exports){\n/*\nCopyright (c) 2011 Juan Mellado\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n/*\nReferences:\n- "OpenCTM: The Open Compressed Triangle Mesh file format" by Marcus Geelnard\n  http://openctm.sourceforge.net/\n*/\n\nif(typeof require !== \'undefined\')\n{\n  var detectEnv = require("composite-detect");\n  if (detectEnv.isModule) var LZMA = require("./lzma");\n}\n\nvar CTM = CTM || {};\n\nCTM.CompressionMethod = {\n  RAW: 0x00574152,\n  MG1: 0x0031474d,\n  MG2: 0x0032474d\n};\n\nCTM.Flags = {\n  NORMALS: 0x00000001\n};\n\nCTM.File = function(stream){\n  this.load(stream);\n};\n\nCTM.File.prototype.getReader = function(){\n  var reader;\n  switch(this.header.compressionMethod){\n    case CTM.CompressionMethod.RAW:\n      reader = new CTM.ReaderRAW();\n      break;\n    case CTM.CompressionMethod.MG1:\n      reader = new CTM.ReaderMG1();\n      break;\n    case CTM.CompressionMethod.MG2:\n      reader = new CTM.ReaderMG2();\n      break;\n  }\n\n  return reader;\n};\n\nCTM.File.prototype.load = function(stream){\n  this.header = new CTM.FileHeader(stream);\n  this.body = new CTM.FileBody(this.header);\n  \n  var reader = this.getReader();\n  reader.read(stream, this.body);\n};\n\nCTM.FileHeader = function(stream){\n  stream.readInt32(); //magic "OCTM"\n  this.fileFormat = stream.readInt32();\n  this.compressionMethod = stream.readInt32();\n  this.vertexCount = stream.readInt32();\n  this.triangleCount = stream.readInt32();\n  this.uvMapCount = stream.readInt32();\n  this.attrMapCount = stream.readInt32();\n  this.flags = stream.readInt32();\n  this.comment = stream.readString();\n};\n\nCTM.FileHeader.prototype.hasNormals = function(){\n  return this.flags & CTM.Flags.NORMALS;\n};\n\nCTM.FileBody = function(header){\n  var i = header.triangleCount * 3,\n      v = header.vertexCount * 3,\n      n = header.hasNormals()? header.vertexCount * 3: 0,\n      u = header.vertexCount * 2,\n      a = header.vertexCount * 4,\n      j = 0;\n\n  var data = new ArrayBuffer(\n    (i + v + n + (u * header.uvMapCount) + (a * header.attrMapCount) ) * 4);\n\n  this.indices = new Uint32Array(data, 0, i);\n\n  this.vertices = new Float32Array(data, i * 4, v);\n\n  if ( header.hasNormals() ){\n    this.normals = new Float32Array(data, (i + v) * 4, n);\n  }\n  \n  if (header.uvMapCount){\n    this.uvMaps = [];\n    for (j = 0; j < header.uvMapCount; ++ j){\n      this.uvMaps[j] = {uv: new Float32Array(data,\n        (i + v + n + (j * u) ) * 4, u) };\n    }\n  }\n  \n  if (header.attrMapCount){\n    this.attrMaps = [];\n    for (j = 0; j < header.attrMapCount; ++ j){\n      this.attrMaps[j] = {attr: new Float32Array(data,\n        (i + v + n + (u * header.uvMapCount) + (j * a) ) * 4, a) };\n    }\n  }\n};\n\nCTM.FileMG2Header = function(stream){\n  stream.readInt32(); //magic "MG2H"\n  this.vertexPrecision = stream.readFloat32();\n  this.normalPrecision = stream.readFloat32();\n  this.lowerBoundx = stream.readFloat32();\n  this.lowerBoundy = stream.readFloat32();\n  this.lowerBoundz = stream.readFloat32();\n  this.higherBoundx = stream.readFloat32();\n  this.higherBoundy = stream.readFloat32();\n  this.higherBoundz = stream.readFloat32();\n  this.divx = stream.readInt32();\n  this.divy = stream.readInt32();\n  this.divz = stream.readInt32();\n  \n  this.sizex = (this.higherBoundx - this.lowerBoundx) / this.divx;\n  this.sizey = (this.higherBoundy - this.lowerBoundy) / this.divy;\n  this.sizez = (this.higherBoundz - this.lowerBoundz) / this.divz;\n};\n\nCTM.ReaderRAW = function(){\n};\n\nCTM.ReaderRAW.prototype.read = function(stream, body){\n  this.readIndices(stream, body.indices);\n  this.readVertices(stream, body.vertices);\n  \n  if (body.normals){\n    this.readNormals(stream, body.normals);\n  }\n  if (body.uvMaps){\n    this.readUVMaps(stream, body.uvMaps);\n  }\n  if (body.attrMaps){\n    this.readAttrMaps(stream, body.attrMaps);\n  }\n};\n\nCTM.ReaderRAW.prototype.readIndices = function(stream, indices){\n  stream.readInt32(); //magic "INDX"\n  stream.readArrayInt32(indices);\n};\n\nCTM.ReaderRAW.prototype.readVertices = function(stream, vertices){\n  stream.readInt32(); //magic "VERT"\n  stream.readArrayFloat32(vertices);\n};\n\nCTM.ReaderRAW.prototype.readNormals = function(stream, normals){\n  stream.readInt32(); //magic "NORM"\n  stream.readArrayFloat32(normals);\n};\n\nCTM.ReaderRAW.prototype.readUVMaps = function(stream, uvMaps){\n  var i = 0;\n  for (; i < uvMaps.length; ++ i){\n    stream.readInt32(); //magic "TEXC"\n\n    uvMaps[i].name = stream.readString();\n    uvMaps[i].filename = stream.readString();\n    stream.readArrayFloat32(uvMaps[i].uv);\n  }\n};\n\nCTM.ReaderRAW.prototype.readAttrMaps = function(stream, attrMaps){\n  var i = 0;\n  for (; i < attrMaps.length; ++ i){\n    stream.readInt32(); //magic "ATTR"\n\n    attrMaps[i].name = stream.readString();\n    stream.readArrayFloat32(attrMaps[i].attr);\n  }\n};\n\nCTM.ReaderMG1 = function(){\n};\n\nCTM.ReaderMG1.prototype.read = function(stream, body){\n  this.readIndices(stream, body.indices);\n  this.readVertices(stream, body.vertices);\n  \n  if (body.normals){\n    this.readNormals(stream, body.normals);\n  }\n  if (body.uvMaps){\n    this.readUVMaps(stream, body.uvMaps);\n  }\n  if (body.attrMaps){\n    this.readAttrMaps(stream, body.attrMaps);\n  }\n};\n\nCTM.ReaderMG1.prototype.readIndices = function(stream, indices){\n  stream.readInt32(); //magic "INDX"\n  stream.readInt32(); //packed size\n  \n  var interleaved = new CTM.InterleavedStream(indices, 3);\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n\n  CTM.restoreIndices(indices, indices.length);\n};\n\nCTM.ReaderMG1.prototype.readVertices = function(stream, vertices){\n  stream.readInt32(); //magic "VERT"\n  stream.readInt32(); //packed size\n  \n  var interleaved = new CTM.InterleavedStream(vertices, 1);\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n};\n\nCTM.ReaderMG1.prototype.readNormals = function(stream, normals){\n  stream.readInt32(); //magic "NORM"\n  stream.readInt32(); //packed size\n\n  var interleaved = new CTM.InterleavedStream(normals, 3);\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n};\n\nCTM.ReaderMG1.prototype.readUVMaps = function(stream, uvMaps){\n  var i = 0;\n  for (; i < uvMaps.length; ++ i){\n    stream.readInt32(); //magic "TEXC"\n\n    uvMaps[i].name = stream.readString();\n    uvMaps[i].filename = stream.readString();\n    \n    stream.readInt32(); //packed size\n\n    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);\n    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n  }\n};\n\nCTM.ReaderMG1.prototype.readAttrMaps = function(stream, attrMaps){\n  var i = 0;\n  for (; i < attrMaps.length; ++ i){\n    stream.readInt32(); //magic "ATTR"\n\n    attrMaps[i].name = stream.readString();\n    \n    stream.readInt32(); //packed size\n\n    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);\n    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n  }\n};\n\nCTM.ReaderMG2 = function(){\n};\n\nCTM.ReaderMG2.prototype.read = function(stream, body){\n  this.MG2Header = new CTM.FileMG2Header(stream);\n  \n  this.readVertices(stream, body.vertices);\n  this.readIndices(stream, body.indices);\n  \n  if (body.normals){\n    this.readNormals(stream, body);\n  }\n  if (body.uvMaps){\n    this.readUVMaps(stream, body.uvMaps);\n  }\n  if (body.attrMaps){\n    this.readAttrMaps(stream, body.attrMaps);\n  }\n};\n\nCTM.ReaderMG2.prototype.readVertices = function(stream, vertices){\n  stream.readInt32(); //magic "VERT"\n  stream.readInt32(); //packed size\n\n  var interleaved = new CTM.InterleavedStream(vertices, 3);\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n  \n  var gridIndices = this.readGridIndices(stream, vertices);\n  \n  CTM.restoreVertices(vertices, this.MG2Header, gridIndices, this.MG2Header.vertexPrecision);\n};\n\nCTM.ReaderMG2.prototype.readGridIndices = function(stream, vertices){\n  stream.readInt32(); //magic "GIDX"\n  stream.readInt32(); //packed size\n  \n  var gridIndices = new Uint32Array(vertices.length / 3);\n  \n  var interleaved = new CTM.InterleavedStream(gridIndices, 1);\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n  \n  CTM.restoreGridIndices(gridIndices, gridIndices.length);\n  \n  return gridIndices;\n};\n\nCTM.ReaderMG2.prototype.readIndices = function(stream, indices){\n  stream.readInt32(); //magic "INDX"\n  stream.readInt32(); //packed size\n\n  var interleaved = new CTM.InterleavedStream(indices, 3);\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n\n  CTM.restoreIndices(indices, indices.length);\n};\n\nCTM.ReaderMG2.prototype.readNormals = function(stream, body){\n  stream.readInt32(); //magic "NORM"\n  stream.readInt32(); //packed size\n\n  var interleaved = new CTM.InterleavedStream(body.normals, 3);\n  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n\n  var smooth = CTM.calcSmoothNormals(body.indices, body.vertices);\n\n  CTM.restoreNormals(body.normals, smooth, this.MG2Header.normalPrecision);\n};\n\nCTM.ReaderMG2.prototype.readUVMaps = function(stream, uvMaps){\n  var i = 0;\n  for (; i < uvMaps.length; ++ i){\n    stream.readInt32(); //magic "TEXC"\n\n    uvMaps[i].name = stream.readString();\n    uvMaps[i].filename = stream.readString();\n    \n    var precision = stream.readFloat32();\n    \n    stream.readInt32(); //packed size\n\n    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);\n    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n    \n    CTM.restoreMap(uvMaps[i].uv, 2, precision);\n  }\n};\n\nCTM.ReaderMG2.prototype.readAttrMaps = function(stream, attrMaps){\n  var i = 0;\n  for (; i < attrMaps.length; ++ i){\n    stream.readInt32(); //magic "ATTR"\n\n    attrMaps[i].name = stream.readString();\n    \n    var precision = stream.readFloat32();\n    \n    stream.readInt32(); //packed size\n\n    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);\n    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n    \n    CTM.restoreMap(attrMaps[i].attr, 4, precision);\n  }\n};\n\nCTM.restoreIndices = function(indices, len){\n  var i = 3;\n  if (len > 0){\n    indices[2] += indices[0];\n    indices[1] += indices[0];\n  }\n  for (; i < len; i += 3){\n    indices[i] += indices[i - 3];\n    \n    if (indices[i] === indices[i - 3]){\n      indices[i + 1] += indices[i - 2];\n    }else{\n      indices[i + 1] += indices[i];\n    }\n\n    indices[i + 2] += indices[i];\n  }\n};\n\nCTM.restoreGridIndices = function(gridIndices, len){\n  var i = 1;\n  for (; i < len; ++ i){\n    gridIndices[i] += gridIndices[i - 1];\n  }\n};\n\nCTM.restoreVertices = function(vertices, grid, gridIndices, precision){\n  var gridIdx, delta, x, y, z,\n      intVertices = new Uint32Array(vertices.buffer, vertices.byteOffset, vertices.length),\n      ydiv = grid.divx, zdiv = ydiv * grid.divy,\n      prevGridIdx = 0x7fffffff, prevDelta = 0,\n      i = 0, j = 0, len = gridIndices.length;\n\n  for (; i < len; j += 3){\n    x = gridIdx = gridIndices[i ++];\n    \n    z = ~~(x / zdiv);\n    x -= ~~(z * zdiv);\n    y = ~~(x / ydiv);\n    x -= ~~(y * ydiv);\n\n    delta = intVertices[j];\n    if (gridIdx === prevGridIdx){\n      delta += prevDelta;\n    }\n\n    vertices[j]     = grid.lowerBoundx +\n      x * grid.sizex + precision * delta;\n    vertices[j + 1] = grid.lowerBoundy +\n      y * grid.sizey + precision * intVertices[j + 1];\n    vertices[j + 2] = grid.lowerBoundz +\n      z * grid.sizez + precision * intVertices[j + 2];\n\n    prevGridIdx = gridIdx;\n    prevDelta = delta;\n  }\n};\n\nCTM.restoreNormals = function(normals, smooth, precision){\n  var ro, phi, theta, sinPhi,\n      nx, ny, nz, by, bz, len,\n      intNormals = new Uint32Array(normals.buffer, normals.byteOffset, normals.length),\n      i = 0, k = normals.length,\n      PI_DIV_2 = 3.141592653589793238462643 * 0.5;\n\n  for (; i < k; i += 3){\n    ro = intNormals[i] * precision;\n    phi = intNormals[i + 1];\n\n    if (phi === 0){\n      normals[i]     = smooth[i]     * ro;\n      normals[i + 1] = smooth[i + 1] * ro;\n      normals[i + 2] = smooth[i + 2] * ro;\n    }else{\n      \n      if (phi <= 4){\n        theta = (intNormals[i + 2] - 2) * PI_DIV_2;\n      }else{\n        theta = ( (intNormals[i + 2] * 4 / phi) - 2) * PI_DIV_2;\n      }\n      \n      phi *= precision * PI_DIV_2;\n      sinPhi = ro * Math.sin(phi);\n\n      nx = sinPhi * Math.cos(theta);\n      ny = sinPhi * Math.sin(theta);\n      nz = ro * Math.cos(phi);\n\n      bz = smooth[i + 1];\n      by = smooth[i] - smooth[i + 2];\n\n      len = Math.sqrt(2 * bz * bz + by * by);\n      if (len > 1e-20){\n        by /= len;\n        bz /= len;\n      }\n\n      normals[i]     = smooth[i]     * nz +\n        (smooth[i + 1] * bz - smooth[i + 2] * by) * ny - bz * nx;\n      normals[i + 1] = smooth[i + 1] * nz -\n        (smooth[i + 2]      + smooth[i]   ) * bz  * ny + by * nx;\n      normals[i + 2] = smooth[i + 2] * nz +\n        (smooth[i]     * by + smooth[i + 1] * bz) * ny + bz * nx;\n    }\n  }\n};\n\nCTM.restoreMap = function(map, count, precision){\n  var delta, value,\n      intMap = new Uint32Array(map.buffer, map.byteOffset, map.length),\n      i = 0, j, len = map.length;\n\n  for (; i < count; ++ i){\n    delta = 0;\n\n    for (j = i; j < len; j += count){\n      value = intMap[j];\n      \n      delta += value & 1? -( (value + 1) >> 1): value >> 1;\n      \n      map[j] = delta * precision;\n    }\n  }\n};\n\nCTM.calcSmoothNormals = function(indices, vertices){\n  var smooth = new Float32Array(vertices.length),\n      indx, indy, indz, nx, ny, nz,\n      v1x, v1y, v1z, v2x, v2y, v2z, len,\n      i, k;\n\n  for (i = 0, k = indices.length; i < k;){\n    indx = indices[i ++] * 3;\n    indy = indices[i ++] * 3;\n    indz = indices[i ++] * 3;\n\n    v1x = vertices[indy]     - vertices[indx];\n    v2x = vertices[indz]     - vertices[indx];\n    v1y = vertices[indy + 1] - vertices[indx + 1];\n    v2y = vertices[indz + 1] - vertices[indx + 1];\n    v1z = vertices[indy + 2] - vertices[indx + 2];\n    v2z = vertices[indz + 2] - vertices[indx + 2];\n    \n    nx = v1y * v2z - v1z * v2y;\n    ny = v1z * v2x - v1x * v2z;\n    nz = v1x * v2y - v1y * v2x;\n    \n    len = Math.sqrt(nx * nx + ny * ny + nz * nz);\n    if (len > 1e-10){\n      nx /= len;\n      ny /= len;\n      nz /= len;\n    }\n    \n    smooth[indx]     += nx;\n    smooth[indx + 1] += ny;\n    smooth[indx + 2] += nz;\n    smooth[indy]     += nx;\n    smooth[indy + 1] += ny;\n    smooth[indy + 2] += nz;\n    smooth[indz]     += nx;\n    smooth[indz + 1] += ny;\n    smooth[indz + 2] += nz;\n  }\n\n  for (i = 0, k = smooth.length; i < k; i += 3){\n    len = Math.sqrt(smooth[i] * smooth[i] + \n      smooth[i + 1] * smooth[i + 1] +\n      smooth[i + 2] * smooth[i + 2]);\n\n    if(len > 1e-10){\n      smooth[i]     /= len;\n      smooth[i + 1] /= len;\n      smooth[i + 2] /= len;\n    }\n  }\n\n  return smooth;\n};\n\nCTM.isLittleEndian = (function(){\n  var buffer = new ArrayBuffer(2),\n      bytes = new Uint8Array(buffer),\n      ints = new Uint16Array(buffer);\n\n  bytes[0] = 1;\n\n  return ints[0] === 1;\n}());\n\nCTM.InterleavedStream = function(data, count){\n  this.data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n  this.offset = CTM.isLittleEndian? 3: 0;\n  this.count = count * 4;\n  this.len = this.data.length;\n};\n\nCTM.InterleavedStream.prototype.writeByte = function(value){\n  this.data[this.offset] = value;\n  \n  this.offset += this.count;\n  if (this.offset >= this.len){\n  \n    this.offset -= this.len - 4;\n    if (this.offset >= this.count){\n    \n      this.offset -= this.count + (CTM.isLittleEndian? 1: -1);\n    }\n  }\n};\n\nCTM.Stream = function(data){\n  this.data = data;\n  this.offset = 0;\n};\n\nCTM.Stream.prototype.TWO_POW_MINUS23 = Math.pow(2, -23);\n\nCTM.Stream.prototype.TWO_POW_MINUS126 = Math.pow(2, -126);\n\nCTM.Stream.prototype.readByte = function(){\n  return this.data[this.offset ++] & 0xff;\n};\n\nCTM.Stream.prototype.readInt32 = function(){\n  var i = this.readByte();\n  i |= this.readByte() << 8;\n  i |= this.readByte() << 16;\n  return i | (this.readByte() << 24);\n};\n\nCTM.Stream.prototype.readFloat32 = function(){\n  var m = this.readByte();\n  m += this.readByte() << 8;\n\n  var b1 = this.readByte();\n  var b2 = this.readByte();\n\n  m += (b1 & 0x7f) << 16; \n  var e = ( (b2 & 0x7f) << 1) | ( (b1 & 0x80) >>> 7);\n  var s = b2 & 0x80? -1: 1;\n\n  if (e === 255){\n    return m !== 0? NaN: s * Infinity;\n  }\n  if (e > 0){\n    return s * (1 + (m * this.TWO_POW_MINUS23) ) * Math.pow(2, e - 127);\n  }\n  if (m !== 0){\n    return s * m * this.TWO_POW_MINUS126;\n  }\n  return s * 0;\n};\n\nCTM.Stream.prototype.readString = function(){\n  var len = this.readInt32();\n\n  this.offset += len;\n\n  return this.data.subarray(this.offset - len, len);\n};\n\nCTM.Stream.prototype.readArrayInt32 = function(array){\n  var i = 0, len = array.length;\n  \n  while(i < len){\n    array[i ++] = this.readInt32();\n  }\n\n  return array;\n};\n\nCTM.Stream.prototype.readArrayFloat32 = function(array){\n  var i = 0, len = array.length;\n\n  while(i < len){\n    array[i ++] = this.readFloat32();\n  }\n\n  return array;\n};\n\n\nif(typeof require !== \'undefined\') if (detectEnv.isModule) module.exports = CTM;\n\n\n},{"./lzma":3,"composite-detect":4}],3:[function(require,module,exports){\nif(typeof require !== \'undefined\')\n{\n  var detectEnv = require("composite-detect");\n}\n\nvar LZMA = LZMA || {};\n\nLZMA.OutWindow = function(){\n  this._windowSize = 0;\n};\n\nLZMA.OutWindow.prototype.create = function(windowSize){\n  if ( (!this._buffer) || (this._windowSize !== windowSize) ){\n    this._buffer = [];\n  }\n  this._windowSize = windowSize;\n  this._pos = 0;\n  this._streamPos = 0;\n};\n\nLZMA.OutWindow.prototype.flush = function(){\n  var size = this._pos - this._streamPos;\n  if (size !== 0){\n    while(size --){\n      this._stream.writeByte(this._buffer[this._streamPos ++]);\n    }\n    if (this._pos >= this._windowSize){\n      this._pos = 0;\n    }\n    this._streamPos = this._pos;\n  }\n};\n\nLZMA.OutWindow.prototype.releaseStream = function(){\n  this.flush();\n  this._stream = null;\n};\n\nLZMA.OutWindow.prototype.setStream = function(stream){\n  this.releaseStream();\n  this._stream = stream;\n};\n\nLZMA.OutWindow.prototype.init = function(solid){\n  if (!solid){\n    this._streamPos = 0;\n    this._pos = 0;\n  }\n};\n\nLZMA.OutWindow.prototype.copyBlock = function(distance, len){\n  var pos = this._pos - distance - 1;\n  if (pos < 0){\n    pos += this._windowSize;\n  }\n  while(len --){\n    if (pos >= this._windowSize){\n      pos = 0;\n    }\n    this._buffer[this._pos ++] = this._buffer[pos ++];\n    if (this._pos >= this._windowSize){\n      this.flush();\n    }\n  }\n};\n\nLZMA.OutWindow.prototype.putByte = function(b){\n  this._buffer[this._pos ++] = b;\n  if (this._pos >= this._windowSize){\n    this.flush();\n  }\n};\n\nLZMA.OutWindow.prototype.getByte = function(distance){\n  var pos = this._pos - distance - 1;\n  if (pos < 0){\n    pos += this._windowSize;\n  }\n  return this._buffer[pos];\n};\n\nLZMA.RangeDecoder = function(){\n};\n\nLZMA.RangeDecoder.prototype.setStream = function(stream){\n  this._stream = stream;\n};\n\nLZMA.RangeDecoder.prototype.releaseStream = function(){\n  this._stream = null;\n};\n\nLZMA.RangeDecoder.prototype.init = function(){\n  var i = 5;\n\n  this._code = 0;\n  this._range = -1;\n  \n  while(i --){\n    this._code = (this._code << 8) | this._stream.readByte();\n  }\n};\n\nLZMA.RangeDecoder.prototype.decodeDirectBits = function(numTotalBits){\n  var result = 0, i = numTotalBits, t;\n\n  while(i --){\n    this._range >>>= 1;\n    t = (this._code - this._range) >>> 31;\n    this._code -= this._range & (t - 1);\n    result = (result << 1) | (1 - t);\n\n    if ( (this._range & 0xff000000) === 0){\n      this._code = (this._code << 8) | this._stream.readByte();\n      this._range <<= 8;\n    }\n  }\n\n  return result;\n};\n\nLZMA.RangeDecoder.prototype.decodeBit = function(probs, index){\n  var prob = probs[index],\n      newBound = (this._range >>> 11) * prob;\n\n  if ( (this._code ^ 0x80000000) < (newBound ^ 0x80000000) ){\n    this._range = newBound;\n    probs[index] += (2048 - prob) >>> 5;\n    if ( (this._range & 0xff000000) === 0){\n      this._code = (this._code << 8) | this._stream.readByte();\n      this._range <<= 8;\n    }\n    return 0;\n  }\n\n  this._range -= newBound;\n  this._code -= newBound;\n  probs[index] -= prob >>> 5;\n  if ( (this._range & 0xff000000) === 0){\n    this._code = (this._code << 8) | this._stream.readByte();\n    this._range <<= 8;\n  }\n  return 1;\n};\n\nLZMA.initBitModels = function(probs, len){\n  while(len --){\n    probs[len] = 1024;\n  }\n};\n\nLZMA.BitTreeDecoder = function(numBitLevels){\n  this._models = [];\n  this._numBitLevels = numBitLevels;\n};\n\nLZMA.BitTreeDecoder.prototype.init = function(){\n  LZMA.initBitModels(this._models, 1 << this._numBitLevels);\n};\n\nLZMA.BitTreeDecoder.prototype.decode = function(rangeDecoder){\n  var m = 1, i = this._numBitLevels;\n\n  while(i --){\n    m = (m << 1) | rangeDecoder.decodeBit(this._models, m);\n  }\n  return m - (1 << this._numBitLevels);\n};\n\nLZMA.BitTreeDecoder.prototype.reverseDecode = function(rangeDecoder){\n  var m = 1, symbol = 0, i = 0, bit;\n\n  for (; i < this._numBitLevels; ++ i){\n    bit = rangeDecoder.decodeBit(this._models, m);\n    m = (m << 1) | bit;\n    symbol |= bit << i;\n  }\n  return symbol;\n};\n\nLZMA.reverseDecode2 = function(models, startIndex, rangeDecoder, numBitLevels){\n  var m = 1, symbol = 0, i = 0, bit;\n\n  for (; i < numBitLevels; ++ i){\n    bit = rangeDecoder.decodeBit(models, startIndex + m);\n    m = (m << 1) | bit;\n    symbol |= bit << i;\n  }\n  return symbol;\n};\n\nLZMA.LenDecoder = function(){\n  this._choice = [];\n  this._lowCoder = [];\n  this._midCoder = [];\n  this._highCoder = new LZMA.BitTreeDecoder(8);\n  this._numPosStates = 0;\n};\n\nLZMA.LenDecoder.prototype.create = function(numPosStates){\n  for (; this._numPosStates < numPosStates; ++ this._numPosStates){\n    this._lowCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);\n    this._midCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);\n  }\n};\n\nLZMA.LenDecoder.prototype.init = function(){\n  var i = this._numPosStates;\n  LZMA.initBitModels(this._choice, 2);\n  while(i --){\n    this._lowCoder[i].init();\n    this._midCoder[i].init();\n  }\n  this._highCoder.init();\n};\n\nLZMA.LenDecoder.prototype.decode = function(rangeDecoder, posState){\n  if (rangeDecoder.decodeBit(this._choice, 0) === 0){\n    return this._lowCoder[posState].decode(rangeDecoder);\n  }\n  if (rangeDecoder.decodeBit(this._choice, 1) === 0){\n    return 8 + this._midCoder[posState].decode(rangeDecoder);\n  }\n  return 16 + this._highCoder.decode(rangeDecoder);\n};\n\nLZMA.Decoder2 = function(){\n  this._decoders = [];\n};\n\nLZMA.Decoder2.prototype.init = function(){\n  LZMA.initBitModels(this._decoders, 0x300);\n};\n\nLZMA.Decoder2.prototype.decodeNormal = function(rangeDecoder){\n  var symbol = 1;\n\n  do{\n    symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);\n  }while(symbol < 0x100);\n\n  return symbol & 0xff;\n};\n\nLZMA.Decoder2.prototype.decodeWithMatchByte = function(rangeDecoder, matchByte){\n  var symbol = 1, matchBit, bit;\n\n  do{\n    matchBit = (matchByte >> 7) & 1;\n    matchByte <<= 1;\n    bit = rangeDecoder.decodeBit(this._decoders, ( (1 + matchBit) << 8) + symbol);\n    symbol = (symbol << 1) | bit;\n    if (matchBit !== bit){\n      while(symbol < 0x100){\n        symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);\n      }\n      break;\n    }\n  }while(symbol < 0x100);\n\n  return symbol & 0xff;\n};\n\nLZMA.LiteralDecoder = function(){\n};\n\nLZMA.LiteralDecoder.prototype.create = function(numPosBits, numPrevBits){\n  var i;\n\n  if (this._coders\n    && (this._numPrevBits === numPrevBits)\n    && (this._numPosBits === numPosBits) ){\n    return;\n  }\n  this._numPosBits = numPosBits;\n  this._posMask = (1 << numPosBits) - 1;\n  this._numPrevBits = numPrevBits;\n\n  this._coders = [];\n\n  i = 1 << (this._numPrevBits + this._numPosBits);\n  while(i --){\n    this._coders[i] = new LZMA.Decoder2();\n  }\n};\n\nLZMA.LiteralDecoder.prototype.init = function(){\n  var i = 1 << (this._numPrevBits + this._numPosBits);\n  while(i --){\n    this._coders[i].init();\n  }\n};\n\nLZMA.LiteralDecoder.prototype.getDecoder = function(pos, prevByte){\n  return this._coders[( (pos & this._posMask) << this._numPrevBits)\n    + ( (prevByte & 0xff) >>> (8 - this._numPrevBits) )];\n};\n\nLZMA.Decoder = function(){\n  this._outWindow = new LZMA.OutWindow();\n  this._rangeDecoder = new LZMA.RangeDecoder();\n  this._isMatchDecoders = [];\n  this._isRepDecoders = [];\n  this._isRepG0Decoders = [];\n  this._isRepG1Decoders = [];\n  this._isRepG2Decoders = [];\n  this._isRep0LongDecoders = [];\n  this._posSlotDecoder = [];\n  this._posDecoders = [];\n  this._posAlignDecoder = new LZMA.BitTreeDecoder(4);\n  this._lenDecoder = new LZMA.LenDecoder();\n  this._repLenDecoder = new LZMA.LenDecoder();\n  this._literalDecoder = new LZMA.LiteralDecoder();\n  this._dictionarySize = -1;\n  this._dictionarySizeCheck = -1;\n\n  this._posSlotDecoder[0] = new LZMA.BitTreeDecoder(6);\n  this._posSlotDecoder[1] = new LZMA.BitTreeDecoder(6);\n  this._posSlotDecoder[2] = new LZMA.BitTreeDecoder(6);\n  this._posSlotDecoder[3] = new LZMA.BitTreeDecoder(6);\n};\n\nLZMA.Decoder.prototype.setDictionarySize = function(dictionarySize){\n  if (dictionarySize < 0){\n    return false;\n  }\n  if (this._dictionarySize !== dictionarySize){\n    this._dictionarySize = dictionarySize;\n    this._dictionarySizeCheck = Math.max(this._dictionarySize, 1);\n    this._outWindow.create( Math.max(this._dictionarySizeCheck, 4096) );\n  }\n  return true;\n};\n\nLZMA.Decoder.prototype.setLcLpPb = function(lc, lp, pb){\n  var numPosStates = 1 << pb;\n\n  if (lc > 8 || lp > 4 || pb > 4){\n    return false;\n  }\n\n  this._literalDecoder.create(lp, lc);\n\n  this._lenDecoder.create(numPosStates);\n  this._repLenDecoder.create(numPosStates);\n  this._posStateMask = numPosStates - 1;\n\n  return true;\n};\n\nLZMA.Decoder.prototype.init = function(){\n  var i = 4;\n\n  this._outWindow.init(false);\n\n  LZMA.initBitModels(this._isMatchDecoders, 192);\n  LZMA.initBitModels(this._isRep0LongDecoders, 192);\n  LZMA.initBitModels(this._isRepDecoders, 12);\n  LZMA.initBitModels(this._isRepG0Decoders, 12);\n  LZMA.initBitModels(this._isRepG1Decoders, 12);\n  LZMA.initBitModels(this._isRepG2Decoders, 12);\n  LZMA.initBitModels(this._posDecoders, 114);\n\n  this._literalDecoder.init();\n\n  while(i --){\n    this._posSlotDecoder[i].init();\n  }\n\n  this._lenDecoder.init();\n  this._repLenDecoder.init();\n  this._posAlignDecoder.init();\n  this._rangeDecoder.init();\n};\n\nLZMA.Decoder.prototype.decode = function(inStream, outStream, outSize){\n  var state = 0, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0,\n      posState, decoder2, len, distance, posSlot, numDirectBits;\n\n  this._rangeDecoder.setStream(inStream);\n  this._outWindow.setStream(outStream);\n\n  this.init();\n\n  while(outSize < 0 || nowPos64 < outSize){\n    posState = nowPos64 & this._posStateMask;\n\n    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << 4) + posState) === 0){\n      decoder2 = this._literalDecoder.getDecoder(nowPos64 ++, prevByte);\n\n      if (state >= 7){\n        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0) );\n      }else{\n        prevByte = decoder2.decodeNormal(this._rangeDecoder);\n      }\n      this._outWindow.putByte(prevByte);\n\n      state = state < 4? 0: state - (state < 10? 3: 6);\n\n    }else{\n\n      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1){\n        len = 0;\n        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0){\n          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << 4) + posState) === 0){\n            state = state < 7? 9: 11;\n            len = 1;\n          }\n        }else{\n          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0){\n            distance = rep1;\n          }else{\n            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0){\n              distance = rep2;\n            }else{\n              distance = rep3;\n              rep3 = rep2;\n            }\n            rep2 = rep1;\n          }\n          rep1 = rep0;\n          rep0 = distance;\n        }\n        if (len === 0){\n          len = 2 + this._repLenDecoder.decode(this._rangeDecoder, posState);\n          state = state < 7? 8: 11;\n        }\n      }else{\n        rep3 = rep2;\n        rep2 = rep1;\n        rep1 = rep0;\n\n        len = 2 + this._lenDecoder.decode(this._rangeDecoder, posState);\n        state = state < 7? 7: 10;\n\n        posSlot = this._posSlotDecoder[len <= 5? len - 2: 3].decode(this._rangeDecoder);\n        if (posSlot >= 4){\n\n          numDirectBits = (posSlot >> 1) - 1;\n          rep0 = (2 | (posSlot & 1) ) << numDirectBits;\n\n          if (posSlot < 14){\n            rep0 += LZMA.reverseDecode2(this._posDecoders,\n                rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);\n          }else{\n            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;\n            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);\n            if (rep0 < 0){\n              if (rep0 === -1){\n                break;\n              }\n              return false;\n            }\n          }\n        }else{\n          rep0 = posSlot;\n        }\n      }\n\n      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck){\n        return false;\n      }\n\n      this._outWindow.copyBlock(rep0, len);\n      nowPos64 += len;\n      prevByte = this._outWindow.getByte(0);\n    }\n  }\n\n  this._outWindow.flush();\n  this._outWindow.releaseStream();\n  this._rangeDecoder.releaseStream();\n\n  return true;\n};\n\nLZMA.Decoder.prototype.setDecoderProperties = function(properties){\n  var value, lc, lp, pb, dictionarySize;\n\n  if (properties.size < 5){\n    return false;\n  }\n\n  value = properties.readByte();\n  lc = value % 9;\n  value = ~~(value / 9);\n  lp = value % 5;\n  pb = ~~(value / 5);\n\n  if ( !this.setLcLpPb(lc, lp, pb) ){\n    return false;\n  }\n\n  dictionarySize = properties.readByte();\n  dictionarySize |= properties.readByte() << 8;\n  dictionarySize |= properties.readByte() << 16;\n  dictionarySize += properties.readByte() * 16777216;\n\n  return this.setDictionarySize(dictionarySize);\n};\n\nLZMA.decompress = function(properties, inStream, outStream, outSize){\n  var decoder = new LZMA.Decoder();\n\n  if ( !decoder.setDecoderProperties(properties) ){\n    throw "Incorrect stream properties";\n  }\n\n  if ( !decoder.decode(inStream, outStream, outSize) ){\n    throw "Error in data stream";\n  }\n\n  return true;\n};\n\nif(typeof require !== \'undefined\') if (detectEnv.isModule) module.exports = LZMA;\n\n\n},{"composite-detect":4}],5:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== \'undefined\'\n    && window.setImmediate;\n    var canPost = typeof window !== \'undefined\'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener(\'message\', function (ev) {\n            if (ev.source === window && ev.data === \'process-tick\') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage(\'process-tick\', \'*\');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = \'browser\';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error(\'process.binding is not supported\');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return \'/\' };\nprocess.chdir = function (dir) {\n    throw new Error(\'process.chdir is not supported\');\n};\n\n},{}],4:[function(require,module,exports){\n(function(process){(function () {\n  // Hueristics.\n  var isNode = typeof process !== \'undefined\' && process.versions && !!process.versions.node;\n  var isBrowser = typeof window !== \'undefined\';\n  var isModule = typeof module !== \'undefined\' && !!module.exports;\n\n  // Export.\n  var detect = (isModule ? exports : (this.detect = {}));\n  detect.isNode = isNode;\n  detect.isBrowser = isBrowser;\n  detect.isModule = isModule;\n}).call(this);\n})(require("__browserify_process"))\n},{"__browserify_process":5}]},{},[1])\n;'],{type:"text/javascript"})));

		worker.onmessage = function( event ) {
			var files = event.data;
			for ( var i = 0; i < files.length; i ++ ) {
				var ctmFile = files[ i ];
				var e1 = Date.now();
				// console.log( "CTM data parse time [worker]: " + (e1-s) + " ms" );
				if ( useBuffers ) {
					var geometry = scope.createModelBuffers( ctmFile );
          deferred.resolve( geometry );
				} else {
					var geometry = scope.createModelClassic( ctmFile );
          deferred.resolve( geometry );
				}
				var e = Date.now();
				console.log( "model load time [worker]: " + (e-e1) + " ms, total: " + (e-s));
			}
		};
	  worker.postMessage( { "data": binaryData, "offsets": offsets } );
	} else {
		for ( var i = 0; i < offsets.length; i ++ ) {
			var stream = new CTM.Stream( binaryData );

      //console.log("stream",stream)
			stream.offset = offsets[ i ];
      //console.log("stream offset", offsets[ i ])
			var ctmFile = new CTM.File( stream );

			if ( useBuffers ) {
				var geometry = scope.createModelBuffers( ctmFile );
        deferred.resolve( geometry );
			} else {
				var geometry = scope.createModelClassic( ctmFile );
        deferred.resolve( geometry );
			}
		 }
		var e = Date.now();
		console.log( "CTM data parse time [inline]: " + (e-s) + " ms" );
	 }

  //return result;
  return deferred.promise;
} 

CTMParser.prototype.createModelBuffers = function ( file ) {
  console.log("creating model buffers")
	var Model = function ( ) {

		var scope = this;

		var reorderVertices = true;

		scope.materials = [];

		THREE.BufferGeometry.call( this );

		var s = Date.now();
		// init GL buffers

		var vertexIndexArray = file.body.indices,
		vertexPositionArray = file.body.vertices,
		vertexNormalArray = file.body.normals;

		var vertexUvArray, vertexColorArray;

		if ( file.body.uvMaps !== undefined && file.body.uvMaps.length > 0 ) {
			vertexUvArray = file.body.uvMaps[ 0 ].uv;
		}

		if ( file.body.attrMaps !== undefined && file.body.attrMaps.length > 0 && file.body.attrMaps[ 0 ].name === "Color" ) {
			vertexColorArray = file.body.attrMaps[ 0 ].attr;
		}

		// reorder vertices
		// (needed for buffer splitting, to keep together face vertices)
		if ( reorderVertices ) {

		    	function copyVertexInfo(v, vt) {

				var sx = v * 3,
			    	    sy = v * 3 + 1,
			    	    sz = v * 3 + 2,

			    	dx = vt * 3,
			    	dy = vt * 3 + 1,
			    	dz = vt * 3 + 2;

				newVertices[ dx ] = vertexPositionArray[ sx ];
				newVertices[ dy ] = vertexPositionArray[ sy ];
				newVertices[ dz ] = vertexPositionArray[ sz ];

				if ( vertexNormalArray ) {
				    newNormals[ dx ] = vertexNormalArray[ sx ];
				    newNormals[ dy ] = vertexNormalArray[ sy ];
				    newNormals[ dz ] = vertexNormalArray[ sz ];
				}

				if ( vertexUvArray ) {
				    newUvs[ vt * 2 ] 	 = vertexUvArray[ v * 2 ];
				    newUvs[ vt * 2 + 1 ] = vertexUvArray[ v * 2 + 1 ];
				}

				if ( vertexColorArray ) {
				    newColors[ vt * 4 ] 	= vertexColorArray[ v * 4 ];
				    newColors[ vt * 4 + 1 ] = vertexColorArray[ v * 4 + 1 ];
				    newColors[ vt * 4 + 2 ] = vertexColorArray[ v * 4 + 2 ];
				    newColors[ vt * 4 + 3 ] = vertexColorArray[ v * 4 + 3 ];
				}
		    	}

		    	function handleVertex( v, iMap ) {

				if ( iMap[ v ] === undefined ) {

					iMap[ v ] = vertexCounter;
                    			reverseIndexMap[vertexCounter] = v;
					vertexCounter += 1;
				}
                		return iMap[ v ];
		    	}

			var newFaces = new Uint32Array( vertexIndexArray.length );
			var indexMap = {}, reverseIndexMap = {}, vertexCounter = 0;

            		var spawledFaceCount = 0,
                	    spawledFaceLimit = Math.ceil(vertexIndexArray.length/3000);
            		var sprawledFaces = new Uint32Array( spawledFaceLimit );  // to store sprawled triangle indices

			for ( var i = 0; i < vertexIndexArray.length; i += 3 ) {

				var a = vertexIndexArray[ i ];
				var b = vertexIndexArray[ i + 1 ];
				var c = vertexIndexArray[ i + 2 ];

				handleVertex( a, indexMap );
				handleVertex( b, indexMap );
				handleVertex( c, indexMap );

				// check for sprawled triangles and put them aside to recreate later
				if ( Math.abs( indexMap[a] - indexMap[b] ) > 65535 ||
                     		     Math.abs( indexMap[b] - indexMap[c] ) > 65535 ||
                     		     Math.abs( indexMap[c] - indexMap[a] ) > 65535 ){

			    		// expand storage when neccessary
			    		if (spawledFaceCount >= spawledFaceLimit) {
						console.warn("reached sprawled faces limit: " + spawledFaceCount);
						spawledFaceLimit *= 2;
						var tArr = new Uint32Array( spawledFaceLimit );
						tArr.set(sprawledFaces);
						sprawledFaces = tArr;
			    		}

                    			sprawledFaces[ spawledFaceCount ] = i;  // starting index in newFaces
                    			spawledFaceCount += 1;
                		}
                		else {

				    newFaces[ i ] 	  = indexMap[ a ];
				    newFaces[ i + 1 ] = indexMap[ b ];
				    newFaces[ i + 2 ] = indexMap[ c ];
                		}
			}
            		// console.log("Number of sprawled faces: " + spawledFaceCount + " current limit: " + spawledFaceLimit +
                        //	" total: " + vertexIndexArray.length/3 + " vertices: " + vertexCounter);

			// create dublicate vertices and update sprawled faces
			var indexMap2 = {},
			    noov = vertexCounter;   // # of original vertices

			for (var isf = 0; isf < spawledFaceCount; isf++ ) {
				var i = sprawledFaces[isf];

				for (var j = 0; j < 3; j++) {
				    var v = vertexIndexArray[ i + j ];
				    newFaces[ i + j] = handleVertex(v, indexMap2);   // new vertex
				}
			}

			// console.log("Created duplicated vertices: " + (vertexCounter - noov));

			// copy xyz, uv, normals and colors into new arrays
			var newVertices = new Float32Array( 3*vertexCounter );
			var newNormals, newUvs, newColors;

			if ( vertexNormalArray ) newNormals = new Float32Array( 3*vertexCounter );
			if ( vertexUvArray ) newUvs = new Float32Array( 2*vertexCounter );
			if ( vertexColorArray ) newColors = new Float32Array( 4*vertexCounter );

			for (var iv = 0; iv < vertexCounter; iv++) {
				copyVertexInfo(reverseIndexMap[iv], iv);
			}

			vertexIndexArray = newFaces;
			vertexPositionArray = newVertices;

			if ( vertexNormalArray ) vertexNormalArray = newNormals;
			if ( vertexUvArray ) vertexUvArray = newUvs;
			if ( vertexColorArray ) vertexColorArray = newColors;
		}

		// compute offsets

		scope.offsets = [];

		var indices = vertexIndexArray;

		var start = 0,
			min = vertexPositionArray.length,
			max = 0,
			minPrev = min;

		for ( var i = 0; i < indices.length; ) {

			for ( var j = 0; j < 3; ++ j ) {

				var idx = indices[ i ++ ];

				if ( idx < min ) min = idx;
				if ( idx > max ) max = idx;

			}

			if ( max - min > 65535 ) {

				i -= 3;

                		if ( minPrev > 0 ) {

				    for ( var k = start; k < i; ++ k )
					    indices[ k ] -= minPrev;
				}

				scope.offsets.push( { start: start, count: i - start, index: minPrev } );

				start = i;
				min = vertexPositionArray.length;
				max = 0;

			}

			minPrev = min;

		}

        	if ( minPrev > 0 ) {

		    for ( var k = start; k < i; ++ k )
			    indices[ k ] -= minPrev;
		}
		scope.offsets.push( { start: start, count: i - start, index: minPrev } );

        	// var e = Date.now();
		// console.log( "Vetex reordering time: " + (e-s) + " ms" );

		// recast CTM 32-bit indices as 16-bit WebGL indices
		var vertexIndexArray16 = new Uint16Array( vertexIndexArray );

		// attributes
		var attributes = scope.attributes;

		attributes[ "index" ]    = { itemSize: 1, array: vertexIndexArray16, numItems: vertexIndexArray16.length };
		attributes[ "position" ] = { itemSize: 3, array: vertexPositionArray, numItems: vertexPositionArray.length };

		if ( vertexNormalArray !== undefined ) {

			attributes[ "normal" ] = { itemSize: 3, array: vertexNormalArray, numItems: vertexNormalArray.length };

		}

		if ( vertexUvArray !== undefined ) {

			attributes[ "uv" ] = { itemSize: 2, array: vertexUvArray, numItems: vertexUvArray.length };

		}

		if ( vertexColorArray !== undefined ) {

			attributes[ "color" ]  = { itemSize: 4, array: vertexColorArray, numItems: vertexColorArray.length };

		}

	}

	Model.prototype = Object.create( THREE.BufferGeometry.prototype );

	var geometry = new Model();

	// compute vertex normals if not present in the CTM model

	if ( geometry.attributes[ "normal" ] === undefined ) {

		geometry.computeVertexNormals();

	}

	//callback( geometry );
  return geometry;
};

CTMParser.prototype.createModelClassic = function ( file ) {

	var Model = function ( ) {

		var scope = this;

		scope.materials = [];

		THREE.Geometry.call( this );

		var normals = [],
			uvs = [],
			colors = [];

		init_vertices( file.body.vertices );

		if ( file.body.normals !== undefined )
			init_normals( file.body.normals );

		if ( file.body.uvMaps !== undefined && file.body.uvMaps.length > 0 )
			init_uvs( file.body.uvMaps[ 0 ].uv );

		if ( file.body.attrMaps !== undefined && file.body.attrMaps.length > 0 && file.body.attrMaps[ 0 ].name === "Color" )
			init_colors( file.body.attrMaps[ 0 ].attr );

		var hasNormals = normals.length > 0 ? true : false,
			hasUvs = uvs.length > 0 ? true : false,
			hasColors = colors.length > 0 ? true : false;

		init_faces( file.body.indices );

		this.computeCentroids();
		this.computeFaceNormals();
		//this.computeTangents();

		function init_vertices( buffer ) {

			var x, y, z, i, il = buffer.length;

			for( i = 0; i < il; i += 3 ) {

				x = buffer[ i ];
				y = buffer[ i + 1 ];
				z = buffer[ i + 2 ];

				vertex( scope, x, y, z );

			}

		};

		function init_normals( buffer ) {

			var x, y, z, i, il = buffer.length;

			for( i = 0; i < il; i += 3 ) {

				x = buffer[ i ];
				y = buffer[ i + 1 ];
				z = buffer[ i + 2 ];

				normals.push( x, y, z );

			}

		};

		function init_colors( buffer ) {

			var r, g, b, a, i, il = buffer.length;

			for( i = 0; i < il; i += 4 ) {

				r = buffer[ i ];
				g = buffer[ i + 1 ];
				b = buffer[ i + 2 ];
				a = buffer[ i + 3 ];

				var color = new THREE.Color();
				color.setRGB( r, g, b );

				colors.push( color );

			}

		};


		function init_uvs( buffer ) {

			var u, v, i, il = buffer.length;

			for( i = 0; i < il; i += 2 ) {

				u = buffer[ i ];
				v = buffer[ i + 1 ];

				uvs.push( u, v );

			}

		};

		function init_faces( buffer ) {

			var a, b, c,
				u1, v1, u2, v2, u3, v3,
				m, face,
				i, il = buffer.length;

			m = 0; // all faces defaulting to material 0

			for( i = 0; i < il; i += 3 ) {

				a = buffer[ i ];
				b = buffer[ i + 1 ];
				c = buffer[ i + 2 ];

				if ( hasNormals ){

					face = f3n( scope, normals, a, b, c, m, a, b, c );

				} else {

					face = f3( scope, a, b, c, m );

				}

				if ( hasColors ) {

					face.vertexColors[ 0 ] = colors[ a ];
					face.vertexColors[ 1 ] = colors[ b ];
					face.vertexColors[ 2 ] = colors[ c ];

				}

				if ( hasUvs ) {

					u1 = uvs[ a * 2 ];
					v1 = uvs[ a * 2 + 1 ];

					u2 = uvs[ b * 2 ];
					v2 = uvs[ b * 2 + 1 ];

					u3 = uvs[ c * 2 ];
					v3 = uvs[ c * 2 + 1 ];

					uv3( scope.faceVertexUvs[ 0 ], u1, v1, u2, v2, u3, v3 );

				}

			}

		}

	};

	function vertex ( scope, x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	};

	function f3 ( scope, a, b, c, mi ) {

		var face = new THREE.Face3( a, b, c, null, null, mi );

		scope.faces.push( face );

		return face;

	};

	function f3n ( scope, normals, a, b, c, mi, nai, nbi, nci ) {

		var nax = normals[ nai * 3     ],
			nay = normals[ nai * 3 + 1 ],
			naz = normals[ nai * 3 + 2 ],

			nbx = normals[ nbi * 3     ],
			nby = normals[ nbi * 3 + 1 ],
			nbz = normals[ nbi * 3 + 2 ],

			ncx = normals[ nci * 3     ],
			ncy = normals[ nci * 3 + 1 ],
			ncz = normals[ nci * 3 + 2 ];

		var na = new THREE.Vector3( nax, nay, naz ),
			nb = new THREE.Vector3( nbx, nby, nbz ),
			nc = new THREE.Vector3( ncx, ncy, ncz );

		var face = new THREE.Face3( a, b, c, [ na, nb, nc ], null, mi );

		scope.faces.push( face );

		return face;

	};

	function uv3 ( where, u1, v1, u2, v2, u3, v3 ) {

		var uv = [];
		uv.push( new THREE.Vector2( u1, v1 ) );
		uv.push( new THREE.Vector2( u2, v2 ) );
		uv.push( new THREE.Vector2( u3, v3 ) );
		where.push( uv );

	};

	Model.prototype = Object.create( THREE.Geometry.prototype );

	//callback( new Model() );
  return new Model();
};

if (detectEnv.isModule) module.exports = CTMParser;

},{"./ctm":3,"composite-detect":false,"q":false,"three":false}],"ctm-parser":[function(require,module,exports){
module.exports=require('suCbHP');
},{}],3:[function(require,module,exports){
/*
Copyright (c) 2011 Juan Mellado

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

/*
References:
- "OpenCTM: The Open Compressed Triangle Mesh file format" by Marcus Geelnard
  http://openctm.sourceforge.net/
*/

if(typeof require !== 'undefined')
{
  var detectEnv = require("composite-detect");
  if (detectEnv.isModule) var LZMA = require("./lzma");
}

var CTM = CTM || {};

CTM.CompressionMethod = {
  RAW: 0x00574152,
  MG1: 0x0031474d,
  MG2: 0x0032474d
};

CTM.Flags = {
  NORMALS: 0x00000001
};

CTM.File = function(stream){
  this.load(stream);
};

CTM.File.prototype.getReader = function(){
  var reader;
  switch(this.header.compressionMethod){
    case CTM.CompressionMethod.RAW:
      reader = new CTM.ReaderRAW();
      break;
    case CTM.CompressionMethod.MG1:
      reader = new CTM.ReaderMG1();
      break;
    case CTM.CompressionMethod.MG2:
      reader = new CTM.ReaderMG2();
      break;
  }

  return reader;
};

CTM.File.prototype.load = function(stream){
  this.header = new CTM.FileHeader(stream);
  this.body = new CTM.FileBody(this.header);
  
  var reader = this.getReader();
  reader.read(stream, this.body);
};

CTM.FileHeader = function(stream){
  stream.readInt32(); //magic "OCTM"
  this.fileFormat = stream.readInt32();
  this.compressionMethod = stream.readInt32();
  this.vertexCount = stream.readInt32();
  this.triangleCount = stream.readInt32();
  this.uvMapCount = stream.readInt32();
  this.attrMapCount = stream.readInt32();
  this.flags = stream.readInt32();
  this.comment = stream.readString();
};

CTM.FileHeader.prototype.hasNormals = function(){
  return this.flags & CTM.Flags.NORMALS;
};

CTM.FileBody = function(header){
  var i = header.triangleCount * 3,
      v = header.vertexCount * 3,
      n = header.hasNormals()? header.vertexCount * 3: 0,
      u = header.vertexCount * 2,
      a = header.vertexCount * 4,
      j = 0;

  var data = new ArrayBuffer(
    (i + v + n + (u * header.uvMapCount) + (a * header.attrMapCount) ) * 4);

  this.indices = new Uint32Array(data, 0, i);

  this.vertices = new Float32Array(data, i * 4, v);

  if ( header.hasNormals() ){
    this.normals = new Float32Array(data, (i + v) * 4, n);
  }
  
  if (header.uvMapCount){
    this.uvMaps = [];
    for (j = 0; j < header.uvMapCount; ++ j){
      this.uvMaps[j] = {uv: new Float32Array(data,
        (i + v + n + (j * u) ) * 4, u) };
    }
  }
  
  if (header.attrMapCount){
    this.attrMaps = [];
    for (j = 0; j < header.attrMapCount; ++ j){
      this.attrMaps[j] = {attr: new Float32Array(data,
        (i + v + n + (u * header.uvMapCount) + (j * a) ) * 4, a) };
    }
  }
};

CTM.FileMG2Header = function(stream){
  stream.readInt32(); //magic "MG2H"
  this.vertexPrecision = stream.readFloat32();
  this.normalPrecision = stream.readFloat32();
  this.lowerBoundx = stream.readFloat32();
  this.lowerBoundy = stream.readFloat32();
  this.lowerBoundz = stream.readFloat32();
  this.higherBoundx = stream.readFloat32();
  this.higherBoundy = stream.readFloat32();
  this.higherBoundz = stream.readFloat32();
  this.divx = stream.readInt32();
  this.divy = stream.readInt32();
  this.divz = stream.readInt32();
  
  this.sizex = (this.higherBoundx - this.lowerBoundx) / this.divx;
  this.sizey = (this.higherBoundy - this.lowerBoundy) / this.divy;
  this.sizez = (this.higherBoundz - this.lowerBoundz) / this.divz;
};

CTM.ReaderRAW = function(){
};

CTM.ReaderRAW.prototype.read = function(stream, body){
  this.readIndices(stream, body.indices);
  this.readVertices(stream, body.vertices);
  
  if (body.normals){
    this.readNormals(stream, body.normals);
  }
  if (body.uvMaps){
    this.readUVMaps(stream, body.uvMaps);
  }
  if (body.attrMaps){
    this.readAttrMaps(stream, body.attrMaps);
  }
};

CTM.ReaderRAW.prototype.readIndices = function(stream, indices){
  stream.readInt32(); //magic "INDX"
  stream.readArrayInt32(indices);
};

CTM.ReaderRAW.prototype.readVertices = function(stream, vertices){
  stream.readInt32(); //magic "VERT"
  stream.readArrayFloat32(vertices);
};

CTM.ReaderRAW.prototype.readNormals = function(stream, normals){
  stream.readInt32(); //magic "NORM"
  stream.readArrayFloat32(normals);
};

CTM.ReaderRAW.prototype.readUVMaps = function(stream, uvMaps){
  var i = 0;
  for (; i < uvMaps.length; ++ i){
    stream.readInt32(); //magic "TEXC"

    uvMaps[i].name = stream.readString();
    uvMaps[i].filename = stream.readString();
    stream.readArrayFloat32(uvMaps[i].uv);
  }
};

CTM.ReaderRAW.prototype.readAttrMaps = function(stream, attrMaps){
  var i = 0;
  for (; i < attrMaps.length; ++ i){
    stream.readInt32(); //magic "ATTR"

    attrMaps[i].name = stream.readString();
    stream.readArrayFloat32(attrMaps[i].attr);
  }
};

CTM.ReaderMG1 = function(){
};

CTM.ReaderMG1.prototype.read = function(stream, body){
  this.readIndices(stream, body.indices);
  this.readVertices(stream, body.vertices);
  
  if (body.normals){
    this.readNormals(stream, body.normals);
  }
  if (body.uvMaps){
    this.readUVMaps(stream, body.uvMaps);
  }
  if (body.attrMaps){
    this.readAttrMaps(stream, body.attrMaps);
  }
};

CTM.ReaderMG1.prototype.readIndices = function(stream, indices){
  stream.readInt32(); //magic "INDX"
  stream.readInt32(); //packed size
  
  var interleaved = new CTM.InterleavedStream(indices, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);

  CTM.restoreIndices(indices, indices.length);
};

CTM.ReaderMG1.prototype.readVertices = function(stream, vertices){
  stream.readInt32(); //magic "VERT"
  stream.readInt32(); //packed size
  
  var interleaved = new CTM.InterleavedStream(vertices, 1);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
};

CTM.ReaderMG1.prototype.readNormals = function(stream, normals){
  stream.readInt32(); //magic "NORM"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(normals, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
};

CTM.ReaderMG1.prototype.readUVMaps = function(stream, uvMaps){
  var i = 0;
  for (; i < uvMaps.length; ++ i){
    stream.readInt32(); //magic "TEXC"

    uvMaps[i].name = stream.readString();
    uvMaps[i].filename = stream.readString();
    
    stream.readInt32(); //packed size

    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);
    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
  }
};

CTM.ReaderMG1.prototype.readAttrMaps = function(stream, attrMaps){
  var i = 0;
  for (; i < attrMaps.length; ++ i){
    stream.readInt32(); //magic "ATTR"

    attrMaps[i].name = stream.readString();
    
    stream.readInt32(); //packed size

    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);
    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
  }
};

CTM.ReaderMG2 = function(){
};

CTM.ReaderMG2.prototype.read = function(stream, body){
  this.MG2Header = new CTM.FileMG2Header(stream);
  
  this.readVertices(stream, body.vertices);
  this.readIndices(stream, body.indices);
  
  if (body.normals){
    this.readNormals(stream, body);
  }
  if (body.uvMaps){
    this.readUVMaps(stream, body.uvMaps);
  }
  if (body.attrMaps){
    this.readAttrMaps(stream, body.attrMaps);
  }
};

CTM.ReaderMG2.prototype.readVertices = function(stream, vertices){
  stream.readInt32(); //magic "VERT"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(vertices, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
  
  var gridIndices = this.readGridIndices(stream, vertices);
  
  CTM.restoreVertices(vertices, this.MG2Header, gridIndices, this.MG2Header.vertexPrecision);
};

CTM.ReaderMG2.prototype.readGridIndices = function(stream, vertices){
  stream.readInt32(); //magic "GIDX"
  stream.readInt32(); //packed size
  
  var gridIndices = new Uint32Array(vertices.length / 3);
  
  var interleaved = new CTM.InterleavedStream(gridIndices, 1);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
  
  CTM.restoreGridIndices(gridIndices, gridIndices.length);
  
  return gridIndices;
};

CTM.ReaderMG2.prototype.readIndices = function(stream, indices){
  stream.readInt32(); //magic "INDX"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(indices, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);

  CTM.restoreIndices(indices, indices.length);
};

CTM.ReaderMG2.prototype.readNormals = function(stream, body){
  stream.readInt32(); //magic "NORM"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(body.normals, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);

  var smooth = CTM.calcSmoothNormals(body.indices, body.vertices);

  CTM.restoreNormals(body.normals, smooth, this.MG2Header.normalPrecision);
};

CTM.ReaderMG2.prototype.readUVMaps = function(stream, uvMaps){
  var i = 0;
  for (; i < uvMaps.length; ++ i){
    stream.readInt32(); //magic "TEXC"

    uvMaps[i].name = stream.readString();
    uvMaps[i].filename = stream.readString();
    
    var precision = stream.readFloat32();
    
    stream.readInt32(); //packed size

    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);
    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
    
    CTM.restoreMap(uvMaps[i].uv, 2, precision);
  }
};

CTM.ReaderMG2.prototype.readAttrMaps = function(stream, attrMaps){
  var i = 0;
  for (; i < attrMaps.length; ++ i){
    stream.readInt32(); //magic "ATTR"

    attrMaps[i].name = stream.readString();
    
    var precision = stream.readFloat32();
    
    stream.readInt32(); //packed size

    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);
    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
    
    CTM.restoreMap(attrMaps[i].attr, 4, precision);
  }
};

CTM.restoreIndices = function(indices, len){
  var i = 3;
  if (len > 0){
    indices[2] += indices[0];
    indices[1] += indices[0];
  }
  for (; i < len; i += 3){
    indices[i] += indices[i - 3];
    
    if (indices[i] === indices[i - 3]){
      indices[i + 1] += indices[i - 2];
    }else{
      indices[i + 1] += indices[i];
    }

    indices[i + 2] += indices[i];
  }
};

CTM.restoreGridIndices = function(gridIndices, len){
  var i = 1;
  for (; i < len; ++ i){
    gridIndices[i] += gridIndices[i - 1];
  }
};

CTM.restoreVertices = function(vertices, grid, gridIndices, precision){
  var gridIdx, delta, x, y, z,
      intVertices = new Uint32Array(vertices.buffer, vertices.byteOffset, vertices.length),
      ydiv = grid.divx, zdiv = ydiv * grid.divy,
      prevGridIdx = 0x7fffffff, prevDelta = 0,
      i = 0, j = 0, len = gridIndices.length;

  for (; i < len; j += 3){
    x = gridIdx = gridIndices[i ++];
    
    z = ~~(x / zdiv);
    x -= ~~(z * zdiv);
    y = ~~(x / ydiv);
    x -= ~~(y * ydiv);

    delta = intVertices[j];
    if (gridIdx === prevGridIdx){
      delta += prevDelta;
    }

    vertices[j]     = grid.lowerBoundx +
      x * grid.sizex + precision * delta;
    vertices[j + 1] = grid.lowerBoundy +
      y * grid.sizey + precision * intVertices[j + 1];
    vertices[j + 2] = grid.lowerBoundz +
      z * grid.sizez + precision * intVertices[j + 2];

    prevGridIdx = gridIdx;
    prevDelta = delta;
  }
};

CTM.restoreNormals = function(normals, smooth, precision){
  var ro, phi, theta, sinPhi,
      nx, ny, nz, by, bz, len,
      intNormals = new Uint32Array(normals.buffer, normals.byteOffset, normals.length),
      i = 0, k = normals.length,
      PI_DIV_2 = 3.141592653589793238462643 * 0.5;

  for (; i < k; i += 3){
    ro = intNormals[i] * precision;
    phi = intNormals[i + 1];

    if (phi === 0){
      normals[i]     = smooth[i]     * ro;
      normals[i + 1] = smooth[i + 1] * ro;
      normals[i + 2] = smooth[i + 2] * ro;
    }else{
      
      if (phi <= 4){
        theta = (intNormals[i + 2] - 2) * PI_DIV_2;
      }else{
        theta = ( (intNormals[i + 2] * 4 / phi) - 2) * PI_DIV_2;
      }
      
      phi *= precision * PI_DIV_2;
      sinPhi = ro * Math.sin(phi);

      nx = sinPhi * Math.cos(theta);
      ny = sinPhi * Math.sin(theta);
      nz = ro * Math.cos(phi);

      bz = smooth[i + 1];
      by = smooth[i] - smooth[i + 2];

      len = Math.sqrt(2 * bz * bz + by * by);
      if (len > 1e-20){
        by /= len;
        bz /= len;
      }

      normals[i]     = smooth[i]     * nz +
        (smooth[i + 1] * bz - smooth[i + 2] * by) * ny - bz * nx;
      normals[i + 1] = smooth[i + 1] * nz -
        (smooth[i + 2]      + smooth[i]   ) * bz  * ny + by * nx;
      normals[i + 2] = smooth[i + 2] * nz +
        (smooth[i]     * by + smooth[i + 1] * bz) * ny + bz * nx;
    }
  }
};

CTM.restoreMap = function(map, count, precision){
  var delta, value,
      intMap = new Uint32Array(map.buffer, map.byteOffset, map.length),
      i = 0, j, len = map.length;

  for (; i < count; ++ i){
    delta = 0;

    for (j = i; j < len; j += count){
      value = intMap[j];
      
      delta += value & 1? -( (value + 1) >> 1): value >> 1;
      
      map[j] = delta * precision;
    }
  }
};

CTM.calcSmoothNormals = function(indices, vertices){
  var smooth = new Float32Array(vertices.length),
      indx, indy, indz, nx, ny, nz,
      v1x, v1y, v1z, v2x, v2y, v2z, len,
      i, k;

  for (i = 0, k = indices.length; i < k;){
    indx = indices[i ++] * 3;
    indy = indices[i ++] * 3;
    indz = indices[i ++] * 3;

    v1x = vertices[indy]     - vertices[indx];
    v2x = vertices[indz]     - vertices[indx];
    v1y = vertices[indy + 1] - vertices[indx + 1];
    v2y = vertices[indz + 1] - vertices[indx + 1];
    v1z = vertices[indy + 2] - vertices[indx + 2];
    v2z = vertices[indz + 2] - vertices[indx + 2];
    
    nx = v1y * v2z - v1z * v2y;
    ny = v1z * v2x - v1x * v2z;
    nz = v1x * v2y - v1y * v2x;
    
    len = Math.sqrt(nx * nx + ny * ny + nz * nz);
    if (len > 1e-10){
      nx /= len;
      ny /= len;
      nz /= len;
    }
    
    smooth[indx]     += nx;
    smooth[indx + 1] += ny;
    smooth[indx + 2] += nz;
    smooth[indy]     += nx;
    smooth[indy + 1] += ny;
    smooth[indy + 2] += nz;
    smooth[indz]     += nx;
    smooth[indz + 1] += ny;
    smooth[indz + 2] += nz;
  }

  for (i = 0, k = smooth.length; i < k; i += 3){
    len = Math.sqrt(smooth[i] * smooth[i] + 
      smooth[i + 1] * smooth[i + 1] +
      smooth[i + 2] * smooth[i + 2]);

    if(len > 1e-10){
      smooth[i]     /= len;
      smooth[i + 1] /= len;
      smooth[i + 2] /= len;
    }
  }

  return smooth;
};

CTM.isLittleEndian = (function(){
  var buffer = new ArrayBuffer(2),
      bytes = new Uint8Array(buffer),
      ints = new Uint16Array(buffer);

  bytes[0] = 1;

  return ints[0] === 1;
}());

CTM.InterleavedStream = function(data, count){
  this.data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  this.offset = CTM.isLittleEndian? 3: 0;
  this.count = count * 4;
  this.len = this.data.length;
};

CTM.InterleavedStream.prototype.writeByte = function(value){
  this.data[this.offset] = value;
  
  this.offset += this.count;
  if (this.offset >= this.len){
  
    this.offset -= this.len - 4;
    if (this.offset >= this.count){
    
      this.offset -= this.count + (CTM.isLittleEndian? 1: -1);
    }
  }
};

CTM.Stream = function(data){
  this.data = data;
  this.offset = 0;
};

CTM.Stream.prototype.TWO_POW_MINUS23 = Math.pow(2, -23);

CTM.Stream.prototype.TWO_POW_MINUS126 = Math.pow(2, -126);

CTM.Stream.prototype.readByte = function(){
  return this.data[this.offset ++] & 0xff;
};

CTM.Stream.prototype.readInt32 = function(){
  var i = this.readByte();
  i |= this.readByte() << 8;
  i |= this.readByte() << 16;
  return i | (this.readByte() << 24);
};

CTM.Stream.prototype.readFloat32 = function(){
  var m = this.readByte();
  m += this.readByte() << 8;

  var b1 = this.readByte();
  var b2 = this.readByte();

  m += (b1 & 0x7f) << 16; 
  var e = ( (b2 & 0x7f) << 1) | ( (b1 & 0x80) >>> 7);
  var s = b2 & 0x80? -1: 1;

  if (e === 255){
    return m !== 0? NaN: s * Infinity;
  }
  if (e > 0){
    return s * (1 + (m * this.TWO_POW_MINUS23) ) * Math.pow(2, e - 127);
  }
  if (m !== 0){
    return s * m * this.TWO_POW_MINUS126;
  }
  return s * 0;
};

CTM.Stream.prototype.readString = function(){
  var len = this.readInt32();

  this.offset += len;

  return this.data.subarray(this.offset - len, len);
};

CTM.Stream.prototype.readArrayInt32 = function(array){
  var i = 0, len = array.length;
  
  while(i < len){
    array[i ++] = this.readInt32();
  }

  return array;
};

CTM.Stream.prototype.readArrayFloat32 = function(array){
  var i = 0, len = array.length;

  while(i < len){
    array[i ++] = this.readFloat32();
  }

  return array;
};


if(typeof require !== 'undefined') if (detectEnv.isModule) module.exports = CTM;


},{"./lzma":4,"composite-detect":false}],4:[function(require,module,exports){
if(typeof require !== 'undefined')
{
  var detectEnv = require("composite-detect");
}

var LZMA = LZMA || {};

LZMA.OutWindow = function(){
  this._windowSize = 0;
};

LZMA.OutWindow.prototype.create = function(windowSize){
  if ( (!this._buffer) || (this._windowSize !== windowSize) ){
    this._buffer = [];
  }
  this._windowSize = windowSize;
  this._pos = 0;
  this._streamPos = 0;
};

LZMA.OutWindow.prototype.flush = function(){
  var size = this._pos - this._streamPos;
  if (size !== 0){
    while(size --){
      this._stream.writeByte(this._buffer[this._streamPos ++]);
    }
    if (this._pos >= this._windowSize){
      this._pos = 0;
    }
    this._streamPos = this._pos;
  }
};

LZMA.OutWindow.prototype.releaseStream = function(){
  this.flush();
  this._stream = null;
};

LZMA.OutWindow.prototype.setStream = function(stream){
  this.releaseStream();
  this._stream = stream;
};

LZMA.OutWindow.prototype.init = function(solid){
  if (!solid){
    this._streamPos = 0;
    this._pos = 0;
  }
};

LZMA.OutWindow.prototype.copyBlock = function(distance, len){
  var pos = this._pos - distance - 1;
  if (pos < 0){
    pos += this._windowSize;
  }
  while(len --){
    if (pos >= this._windowSize){
      pos = 0;
    }
    this._buffer[this._pos ++] = this._buffer[pos ++];
    if (this._pos >= this._windowSize){
      this.flush();
    }
  }
};

LZMA.OutWindow.prototype.putByte = function(b){
  this._buffer[this._pos ++] = b;
  if (this._pos >= this._windowSize){
    this.flush();
  }
};

LZMA.OutWindow.prototype.getByte = function(distance){
  var pos = this._pos - distance - 1;
  if (pos < 0){
    pos += this._windowSize;
  }
  return this._buffer[pos];
};

LZMA.RangeDecoder = function(){
};

LZMA.RangeDecoder.prototype.setStream = function(stream){
  this._stream = stream;
};

LZMA.RangeDecoder.prototype.releaseStream = function(){
  this._stream = null;
};

LZMA.RangeDecoder.prototype.init = function(){
  var i = 5;

  this._code = 0;
  this._range = -1;
  
  while(i --){
    this._code = (this._code << 8) | this._stream.readByte();
  }
};

LZMA.RangeDecoder.prototype.decodeDirectBits = function(numTotalBits){
  var result = 0, i = numTotalBits, t;

  while(i --){
    this._range >>>= 1;
    t = (this._code - this._range) >>> 31;
    this._code -= this._range & (t - 1);
    result = (result << 1) | (1 - t);

    if ( (this._range & 0xff000000) === 0){
      this._code = (this._code << 8) | this._stream.readByte();
      this._range <<= 8;
    }
  }

  return result;
};

LZMA.RangeDecoder.prototype.decodeBit = function(probs, index){
  var prob = probs[index],
      newBound = (this._range >>> 11) * prob;

  if ( (this._code ^ 0x80000000) < (newBound ^ 0x80000000) ){
    this._range = newBound;
    probs[index] += (2048 - prob) >>> 5;
    if ( (this._range & 0xff000000) === 0){
      this._code = (this._code << 8) | this._stream.readByte();
      this._range <<= 8;
    }
    return 0;
  }

  this._range -= newBound;
  this._code -= newBound;
  probs[index] -= prob >>> 5;
  if ( (this._range & 0xff000000) === 0){
    this._code = (this._code << 8) | this._stream.readByte();
    this._range <<= 8;
  }
  return 1;
};

LZMA.initBitModels = function(probs, len){
  while(len --){
    probs[len] = 1024;
  }
};

LZMA.BitTreeDecoder = function(numBitLevels){
  this._models = [];
  this._numBitLevels = numBitLevels;
};

LZMA.BitTreeDecoder.prototype.init = function(){
  LZMA.initBitModels(this._models, 1 << this._numBitLevels);
};

LZMA.BitTreeDecoder.prototype.decode = function(rangeDecoder){
  var m = 1, i = this._numBitLevels;

  while(i --){
    m = (m << 1) | rangeDecoder.decodeBit(this._models, m);
  }
  return m - (1 << this._numBitLevels);
};

LZMA.BitTreeDecoder.prototype.reverseDecode = function(rangeDecoder){
  var m = 1, symbol = 0, i = 0, bit;

  for (; i < this._numBitLevels; ++ i){
    bit = rangeDecoder.decodeBit(this._models, m);
    m = (m << 1) | bit;
    symbol |= bit << i;
  }
  return symbol;
};

LZMA.reverseDecode2 = function(models, startIndex, rangeDecoder, numBitLevels){
  var m = 1, symbol = 0, i = 0, bit;

  for (; i < numBitLevels; ++ i){
    bit = rangeDecoder.decodeBit(models, startIndex + m);
    m = (m << 1) | bit;
    symbol |= bit << i;
  }
  return symbol;
};

LZMA.LenDecoder = function(){
  this._choice = [];
  this._lowCoder = [];
  this._midCoder = [];
  this._highCoder = new LZMA.BitTreeDecoder(8);
  this._numPosStates = 0;
};

LZMA.LenDecoder.prototype.create = function(numPosStates){
  for (; this._numPosStates < numPosStates; ++ this._numPosStates){
    this._lowCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);
    this._midCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);
  }
};

LZMA.LenDecoder.prototype.init = function(){
  var i = this._numPosStates;
  LZMA.initBitModels(this._choice, 2);
  while(i --){
    this._lowCoder[i].init();
    this._midCoder[i].init();
  }
  this._highCoder.init();
};

LZMA.LenDecoder.prototype.decode = function(rangeDecoder, posState){
  if (rangeDecoder.decodeBit(this._choice, 0) === 0){
    return this._lowCoder[posState].decode(rangeDecoder);
  }
  if (rangeDecoder.decodeBit(this._choice, 1) === 0){
    return 8 + this._midCoder[posState].decode(rangeDecoder);
  }
  return 16 + this._highCoder.decode(rangeDecoder);
};

LZMA.Decoder2 = function(){
  this._decoders = [];
};

LZMA.Decoder2.prototype.init = function(){
  LZMA.initBitModels(this._decoders, 0x300);
};

LZMA.Decoder2.prototype.decodeNormal = function(rangeDecoder){
  var symbol = 1;

  do{
    symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);
  }while(symbol < 0x100);

  return symbol & 0xff;
};

LZMA.Decoder2.prototype.decodeWithMatchByte = function(rangeDecoder, matchByte){
  var symbol = 1, matchBit, bit;

  do{
    matchBit = (matchByte >> 7) & 1;
    matchByte <<= 1;
    bit = rangeDecoder.decodeBit(this._decoders, ( (1 + matchBit) << 8) + symbol);
    symbol = (symbol << 1) | bit;
    if (matchBit !== bit){
      while(symbol < 0x100){
        symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);
      }
      break;
    }
  }while(symbol < 0x100);

  return symbol & 0xff;
};

LZMA.LiteralDecoder = function(){
};

LZMA.LiteralDecoder.prototype.create = function(numPosBits, numPrevBits){
  var i;

  if (this._coders
    && (this._numPrevBits === numPrevBits)
    && (this._numPosBits === numPosBits) ){
    return;
  }
  this._numPosBits = numPosBits;
  this._posMask = (1 << numPosBits) - 1;
  this._numPrevBits = numPrevBits;

  this._coders = [];

  i = 1 << (this._numPrevBits + this._numPosBits);
  while(i --){
    this._coders[i] = new LZMA.Decoder2();
  }
};

LZMA.LiteralDecoder.prototype.init = function(){
  var i = 1 << (this._numPrevBits + this._numPosBits);
  while(i --){
    this._coders[i].init();
  }
};

LZMA.LiteralDecoder.prototype.getDecoder = function(pos, prevByte){
  return this._coders[( (pos & this._posMask) << this._numPrevBits)
    + ( (prevByte & 0xff) >>> (8 - this._numPrevBits) )];
};

LZMA.Decoder = function(){
  this._outWindow = new LZMA.OutWindow();
  this._rangeDecoder = new LZMA.RangeDecoder();
  this._isMatchDecoders = [];
  this._isRepDecoders = [];
  this._isRepG0Decoders = [];
  this._isRepG1Decoders = [];
  this._isRepG2Decoders = [];
  this._isRep0LongDecoders = [];
  this._posSlotDecoder = [];
  this._posDecoders = [];
  this._posAlignDecoder = new LZMA.BitTreeDecoder(4);
  this._lenDecoder = new LZMA.LenDecoder();
  this._repLenDecoder = new LZMA.LenDecoder();
  this._literalDecoder = new LZMA.LiteralDecoder();
  this._dictionarySize = -1;
  this._dictionarySizeCheck = -1;

  this._posSlotDecoder[0] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[1] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[2] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[3] = new LZMA.BitTreeDecoder(6);
};

LZMA.Decoder.prototype.setDictionarySize = function(dictionarySize){
  if (dictionarySize < 0){
    return false;
  }
  if (this._dictionarySize !== dictionarySize){
    this._dictionarySize = dictionarySize;
    this._dictionarySizeCheck = Math.max(this._dictionarySize, 1);
    this._outWindow.create( Math.max(this._dictionarySizeCheck, 4096) );
  }
  return true;
};

LZMA.Decoder.prototype.setLcLpPb = function(lc, lp, pb){
  var numPosStates = 1 << pb;

  if (lc > 8 || lp > 4 || pb > 4){
    return false;
  }

  this._literalDecoder.create(lp, lc);

  this._lenDecoder.create(numPosStates);
  this._repLenDecoder.create(numPosStates);
  this._posStateMask = numPosStates - 1;

  return true;
};

LZMA.Decoder.prototype.init = function(){
  var i = 4;

  this._outWindow.init(false);

  LZMA.initBitModels(this._isMatchDecoders, 192);
  LZMA.initBitModels(this._isRep0LongDecoders, 192);
  LZMA.initBitModels(this._isRepDecoders, 12);
  LZMA.initBitModels(this._isRepG0Decoders, 12);
  LZMA.initBitModels(this._isRepG1Decoders, 12);
  LZMA.initBitModels(this._isRepG2Decoders, 12);
  LZMA.initBitModels(this._posDecoders, 114);

  this._literalDecoder.init();

  while(i --){
    this._posSlotDecoder[i].init();
  }

  this._lenDecoder.init();
  this._repLenDecoder.init();
  this._posAlignDecoder.init();
  this._rangeDecoder.init();
};

LZMA.Decoder.prototype.decode = function(inStream, outStream, outSize){
  var state = 0, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0,
      posState, decoder2, len, distance, posSlot, numDirectBits;

  this._rangeDecoder.setStream(inStream);
  this._outWindow.setStream(outStream);

  this.init();

  while(outSize < 0 || nowPos64 < outSize){
    posState = nowPos64 & this._posStateMask;

    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << 4) + posState) === 0){
      decoder2 = this._literalDecoder.getDecoder(nowPos64 ++, prevByte);

      if (state >= 7){
        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0) );
      }else{
        prevByte = decoder2.decodeNormal(this._rangeDecoder);
      }
      this._outWindow.putByte(prevByte);

      state = state < 4? 0: state - (state < 10? 3: 6);

    }else{

      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1){
        len = 0;
        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0){
          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << 4) + posState) === 0){
            state = state < 7? 9: 11;
            len = 1;
          }
        }else{
          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0){
            distance = rep1;
          }else{
            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0){
              distance = rep2;
            }else{
              distance = rep3;
              rep3 = rep2;
            }
            rep2 = rep1;
          }
          rep1 = rep0;
          rep0 = distance;
        }
        if (len === 0){
          len = 2 + this._repLenDecoder.decode(this._rangeDecoder, posState);
          state = state < 7? 8: 11;
        }
      }else{
        rep3 = rep2;
        rep2 = rep1;
        rep1 = rep0;

        len = 2 + this._lenDecoder.decode(this._rangeDecoder, posState);
        state = state < 7? 7: 10;

        posSlot = this._posSlotDecoder[len <= 5? len - 2: 3].decode(this._rangeDecoder);
        if (posSlot >= 4){

          numDirectBits = (posSlot >> 1) - 1;
          rep0 = (2 | (posSlot & 1) ) << numDirectBits;

          if (posSlot < 14){
            rep0 += LZMA.reverseDecode2(this._posDecoders,
                rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);
          }else{
            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;
            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);
            if (rep0 < 0){
              if (rep0 === -1){
                break;
              }
              return false;
            }
          }
        }else{
          rep0 = posSlot;
        }
      }

      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck){
        return false;
      }

      this._outWindow.copyBlock(rep0, len);
      nowPos64 += len;
      prevByte = this._outWindow.getByte(0);
    }
  }

  this._outWindow.flush();
  this._outWindow.releaseStream();
  this._rangeDecoder.releaseStream();

  return true;
};

LZMA.Decoder.prototype.setDecoderProperties = function(properties){
  var value, lc, lp, pb, dictionarySize;

  if (properties.size < 5){
    return false;
  }

  value = properties.readByte();
  lc = value % 9;
  value = ~~(value / 9);
  lp = value % 5;
  pb = ~~(value / 5);

  if ( !this.setLcLpPb(lc, lp, pb) ){
    return false;
  }

  dictionarySize = properties.readByte();
  dictionarySize |= properties.readByte() << 8;
  dictionarySize |= properties.readByte() << 16;
  dictionarySize += properties.readByte() * 16777216;

  return this.setDictionarySize(dictionarySize);
};

LZMA.decompress = function(properties, inStream, outStream, outSize){
  var decoder = new LZMA.Decoder();

  if ( !decoder.setDecoderProperties(properties) ){
    throw "Incorrect stream properties";
  }

  if ( !decoder.decode(inStream, outStream, outSize) ){
    throw "Error in data stream";
  }

  return true;
};

if(typeof require !== 'undefined') if (detectEnv.isModule) module.exports = LZMA;


},{"composite-detect":false}]},{},["suCbHP"])