'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inputDataType = exports.outputs = undefined;
exports.default = parse;

var _compositeDetect = require('composite-detect');

var _compositeDetect2 = _interopRequireDefault(_compositeDetect);

var _assign = require('fast.js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _rx = require('rx');

var _rx2 = _interopRequireDefault(_rx);

var _ctm = require('./ctm');

var _ctm2 = _interopRequireDefault(_ctm);

var _utils = require('./utils');

var _parseHelpers = require('./parseHelpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import {parseSteps} from './parseHelpers'

/**
 * Loader for CTM encoded models generated by OpenCTM tools:
 *	http://openctm.sourceforge.net/
 *
 * Uses js-openctm library by Juan Mellado
 *	http://code.google.com/p/js-openctm/
 *
 * @author alteredq / http://alteredqualia.com/
 * heavilly modified by kaosat-dev
 */

var outputs = exports.outputs = ['geometry']; // to be able to auto determine data type(s) fetched by parser
var inputDataType = exports.inputDataType = 'arrayBuffer'; // to be able to set required input data type

// Load CTM compressed models
function parse(data) {
  var parameters = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var defaults = {
    useWorker: _compositeDetect2.default.isBrowser === true,
    offsets: [0]
  };
  parameters = (0, _assign2.default)({}, defaults, parameters);

  var _parameters = parameters;
  var useWorker = _parameters.useWorker;
  var offsets = _parameters.offsets;

  var obs = new _rx2.default.ReplaySubject(1);

  var length = 0;
  data = (0, _utils.ensureArrayBuffer)(data);

  var binaryData = new Uint8Array(data);
  var result = null;

  // var binaryData = new Uint8Array(data)
  // var binaryData = new Uint8Array( new ArrayBuffer(data) )
  // var binaryData = new Buffer( new Uint8Array(data) )

  // TODO: this is only temporary for NODE.js side
  // var data = toArrayBuffer(data)

  if (useWorker) {
    (function () {
      // let Worker = require("./worker.js");//Webpack worker!
      // var worker = new Worker

      var worker = new Worker('./worker.js'); // browserify

      worker.onmessage = function (event) {
        var files = event.data;

        files.forEach(function (ctmFile) {
          var geometry = (0, _parseHelpers.createModelBuffers)(ctmFile);
          // obs.onNext({progress: 1, total:Math.NaN})
          obs.onNext(geometry);
        });

        obs.onNext({ progress: 1, total: Math.NaN });
        obs.onCompleted();
      };
      worker.onerror = function (event) {
        obs.onError('filename:' + event.filename + ' lineno: ' + event.lineno + ' error: ' + event.message);
      };

      worker.postMessage({ 'data': binaryData, 'offsets': offsets });
      obs.catch(function (e) {
        return worker.terminate();
      });
    })();
  } else {
    for (var i = 0; i < offsets.length; i++) {
      try {
        var stream = new _ctm2.default.Stream(binaryData);

        stream.offset = offsets[i];
        var ctmFile = new _ctm2.default.File(stream);

        var geometry = (0, _parseHelpers.createModelBuffers)(ctmFile);
        // obs.onNext({progress: 1, total:Math.NaN})
        obs.onNext(geometry);
      } catch (error) {
        obs.onError(error);
      }
    }

    // obs.onNext({progress: 1, total:Math.NaN})
    // obs.onCompleted()
  }
  return obs;
}